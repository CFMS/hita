
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>DOCUMENT TITLE</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-01-26"><meta name="DC.source" content="spectrum.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h1>DOCUMENT TITLE</h1><!--introduction--><p>INTRODUCTORY TEXT</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Clear complete workspace</a></li><li><a href="#2">Read data files</a></li><li><a href="#3">3D</a></li><li><a href="#4">Set some neccessary parameters</a></li><li><a href="#5">3D</a></li><li><a href="#6">Compute FFT</a></li><li><a href="#7">Compute correlations</a></li><li><a href="#8">Show graphs</a></li><li><a href="#9">compute length scales</a></li><li><a href="#10">compute 1D spectrum</a></li><li><a href="#11">compute spectrum</a></li><li><a href="#12">compute k vector</a></li><li><a href="#13">compute 1D spectrum</a></li></ul></div><h2>Clear complete workspace<a name="1"></a></h2><p>Its always a good idea to clear the complete workspace and the command window also closing all figures might be helpful. You may also use the header defin some neccessary flags distinguishing bewteen different data sets.</p><pre class="codeinput">close <span class="string">all</span>
clear <span class="string">all</span>
clc

flag=<span class="string">'2D'</span>;
datadir=<span class="string">'data'</span>;
</pre><h2>Read data files<a name="2"></a></h2><p>Read in the data files and measure the time for reading. The output of the tic/toc block is in seconds. What you should get from the tic/toc block is that most of the time is spend during data I/O. The actual computation needs only ??? of the time of the I/O operations.</p><h2>3D<a name="3"></a></h2><pre class="codeinput"><span class="keyword">if</span> (strcmp(<span class="string">'3D'</span>,flag))
    tic; <span class="comment">% enable timer</span>
    uvel=importdata([datadir,<span class="string">'/'</span>,flag,<span class="string">'/uvel'</span>]);
    vvel=importdata([datadir,<span class="string">'/'</span>,flag,<span class="string">'/vvel'</span>]);
    wvel=importdata([datadir,<span class="string">'/'</span>,flag,<span class="string">'/wvel'</span>]);
    time_reading = toc; <span class="comment">% end timer</span>
<span class="keyword">end</span>
<span class="comment">%%% 2D</span>
<span class="keyword">if</span> (strcmp(<span class="string">'2D'</span>,flag))
    tic;
    uvel=importdata([datadir,<span class="string">'/'</span>,flag,<span class="string">'/uvel'</span>]);
    vvel=importdata([datadir,<span class="string">'/'</span>,flag,<span class="string">'/vvel'</span>]);
    time_reading = toc;
<span class="keyword">end</span>
</pre><h2>Set some neccessary parameters<a name="4"></a></h2><p>For further computations it is important to define some parmeters of the DNS simulation such as domain size, grid spacing, and the number of grid points.</p><h2>3D<a name="5"></a></h2><pre class="codeinput"><span class="keyword">if</span> (strcmp(<span class="string">'3D'</span>,flag))
    dim=256; <span class="comment">% number of points in one dimension</span>
    Lx=5e-3; <span class="comment">% domain size</span>
    Ly=Lx;
    Lz=Lx;
    dx=Lx/dim; <span class="comment">% grid spacing</span>
    dy=dx;
    dz=dx;
    nu=1.7e-5; <span class="comment">% viscosity</span>
    u=reshape(uvel,dim,dim,dim); <span class="comment">% reshape arrays to have them in 3D</span>
    v=reshape(vvel,dim,dim,dim);
    w=reshape(wvel,dim,dim,dim);
<span class="keyword">end</span>
<span class="comment">%%% 2D</span>
<span class="keyword">if</span> (strcmp(<span class="string">'2D'</span>,flag))
    dim=1024; <span class="comment">% number of points in one dimension</span>
    Lx=1E-2;  <span class="comment">% domain size</span>
    Ly=Lx;
    dx=Lx/dim; <span class="comment">% grid spacing</span>
    dy=dx;
    u=reshape(uvel,dim,dim); <span class="comment">% reshape arrays to have them in 2D</span>
    v=reshape(vvel,dim,dim);
<span class="keyword">end</span>
</pre><h2>Compute FFT<a name="6"></a></h2><p>This is the most important part of the script. Since the performance of an actual DFT is rather bad the preferred choice is a FFT. The FFT approach is fastest if the data set to be transformed has a size that is a multiple of two. Thats why the function <b>nextpow2</b> is used to get the next powert of two approximating the dimension <i>dim</i> of the data set. As a consequence the data set is zero padded or truncated. Since the output of an FFT operation is symmetric we only need to save half the transform. <a href="latex">latex</a> \begin{tabular}{|c|c|} \hline <img src="spectrum_eq25947.png" alt="$n$"> &amp; <img src="spectrum_eq44642.png" alt="$n!$"> \\ \hline 1 &amp; 1 \\ 2 &amp; 2 \\ 3 &amp; 6 \\ \hline \end{tabular} <a href="/latex">/latex</a></p><p></p><pre class="codeinput"><span class="keyword">if</span> (strcmp(<span class="string">'3D'</span>,flag))
    tic;
    NFFT = 2.^nextpow2(size(u)); <span class="comment">% Next power of 2 from length of u</span>
    u_fft=fftn(u,NFFT);
    <span class="comment">%</span>
    NFFT = 2.^nextpow2(size(v));
    v_fft=fftn(v,NFFT);
    <span class="comment">%</span>
    NFFT = 2.^nextpow2(size(w));
    w_fft=fftn(w,NFFT);
    time_fft=toc;

    phi_x=u_fft.*conj(u_fft)/dim^6;
    phi_y=v_fft.*conj(v_fft)/dim^6;
    phi_z=w_fft.*conj(w_fft)/dim^6;
<span class="keyword">end</span>
<span class="keyword">if</span> (strcmp(<span class="string">'2D'</span>,flag))
    NFFT = 2.^nextpow2(size(u));
    u_fft=fft2(u,NFFT(1),NFFT(2))./(2*pi)^2; <span class="comment">%2pi comes from the definition of FFT</span>
<span class="comment">%     u_fft = u_fft(1:NFFT(1)/2+1,1:NFFT(2)/2+1);</span>
    NFFT = 2.^nextpow2(size(v));
    v_fft=fft2(v,NFFT(1),NFFT(2))./(2*pi)^2;
<span class="comment">%     v_fft = v_fft(1:NFFT(1)/2+1,1:NFFT(2)/2+1);</span>

    phi_x=u_fft.*conj(u_fft)/size(u,1).^2/size(u,2).^2;
    phi_y=v_fft.*conj(v_fft)/size(v,1).^2/size(v,2).^2;
<span class="keyword">end</span>
</pre><h2>Compute correlations<a name="7"></a></h2><p>Computing a correlation can be a tedious work (requireing tremendous effort) especially if you have large data sets. From theory it is well known that the multiplication of the transform of a data set and ist complex conjugate give a accurate representation of the correlation function. Using the FFT approach this gives an enormeous speed advantage.</p><pre class="codeinput"><span class="keyword">if</span> (strcmp(<span class="string">'3D'</span>,flag))
    R11=ifftn(u_fft.*conj(u_fft))/dim^3/std2(u)^2;
    R22=ifftn(u_fft.*conj(u_fft))/dim^3/std2(v)^2;
    R33=ifftn(u_fft.*conj(u_fft))/dim^3/std2(w)^2;
    R11=R11(1:round(size(R11,1)/2),1,1);
    R22=R22(1:round(size(R22,1)/2),1,1);
    R33=R33(1:round(size(R33,1)/2),1,1);
    r = linspace(0,Lx/2,dim/2)/(Lx/2);
<span class="keyword">else</span>
    NFFT = 2.^nextpow2(size(u_fft));
    R1 = ifft2(u_fft.*conj(u_fft),NFFT(1),NFFT(2))<span class="keyword">...</span>
                ./NFFT(1)./NFFT(2)./std2(u)^2 <span class="keyword">...</span>
                .*(2*pi)^4; <span class="comment">% scaling due to division by 2*pi</span>
    <span class="comment">%</span>
    NFFT = 2.^nextpow2(size(v_fft));
    R2 = ifft2(v_fft.*conj(v_fft),NFFT(1),NFFT(2))<span class="keyword">...</span>
                ./NFFT(1)./NFFT(2)./std2(v)^2 <span class="keyword">...</span>
                .*(2*pi)^4; <span class="comment">% scaling due to division by 2*pi</span>
<span class="comment">%     R11= ifftn(fftn(u).*conj(fftn(u))/dim^2/std2(u)^2);</span>
<span class="comment">%     R22=ifftn(fftn(v).*conj(fftn(v))/dim^2/std2(v)^2);</span>
    R11 = (R1(1:round(size(R1,1)/2),1) + <span class="keyword">...</span>
           R2(1,1:round(size(R2,1)/2))')/2;
    R22 = (R2(1:round(size(R2,1)/2),1) + <span class="keyword">...</span>
           R1(1,1:round(size(R1,1)/2))')/2;

<span class="comment">%     R11 = (R11 + R2(1,1:round(size(R2,1)/2))')/2;</span>

<span class="comment">%     r = linspace(0,Lx/2,dim/2)/(Lx/2);</span>
<span class="comment">%     test = R11 + r'/2.*gradient(R11,max(diff(r)));</span>
<span class="comment">%     plot(r,R11,r,R22,r,test)</span>
<span class="comment">%     legend('R11','R22','Equation');</span>
<span class="comment">%     h=line([0 1],[0 0],'Color',[0 0 0],'LineWidth',1.0);</span>
<span class="keyword">end</span>
</pre><h2>Show graphs<a name="8"></a></h2><pre class="codeinput">pcolor(fftshift(R1));shading <span class="string">interp</span>;title(<span class="string">'R11'</span>);
figure
pcolor(fftshift(R2));shading <span class="string">interp</span>;title(<span class="string">'R22'</span>);
</pre><img vspace="5" hspace="5" src="spectrum_01.jpg" alt=""> <img vspace="5" hspace="5" src="spectrum_02.jpg" alt=""> <h2>compute length scales<a name="9"></a></h2><pre class="codeinput">L11=trapz(r,R11);
L22=trapz(r,R22);
hold <span class="string">on</span>
rectangle(<span class="string">'Position'</span>,[0,0,L11,1],<span class="string">'LineWidth'</span>,2,<span class="string">'LineStyle'</span>,<span class="string">'--'</span>)
</pre><pre class="codeoutput">Undefined function or variable 'r'.

Error in spectrum (line 163)
L11=trapz(r,R11);
</pre><h2>compute 1D spectrum<a name="10"></a></h2><pre class="codeinput">L=length(R1);
NFFT=2^nextpow2(L);
spec_1D=fft(R1(:,1),NFFT)/L.*2/pi;

f = linspace(0,1,NFFT)*2*pi/dx;

slope=1.5*664092^(2/3)*(f.^(-5/3));
<span class="comment">% loglog(f,2*abs(spec_(1:NFFT/2+1)));</span>
<span class="comment">% hold on</span>
<span class="comment">% loglog(f,slope);</span>
</pre><h2>compute spectrum<a name="11"></a></h2><p>spec = zeros(round(dim*dim*dim/8),1);</p><pre class="codeinput"><span class="keyword">if</span> (strcmp(<span class="string">'3D'</span>,flag))
<span class="comment">%     phi = u_fft;</span>
<span class="comment">%     phi(:,:,:)=0.0;</span>
<span class="comment">%     for k=1:dim</span>
<span class="comment">%         for j=1:dim</span>
<span class="comment">%             for i=1:dim</span>
    <span class="comment">%             kappa = sqrt(i*i+j*j+k*k);</span>
    <span class="comment">%             kappa_pos=int16(kappa);</span>
    <span class="comment">%             if (kappa_pos &lt;= size(spec,1))</span>
    <span class="comment">%                 spec(kappa_pos) = spec(kappa_pos)+kappa*kappa*(...</span>
    <span class="comment">%                 + real(u_fft(i,j,k))*real(u_fft(i,j,k))+imag(u_fft(i,j,k))*imag(u_fft(i,j,k)) ...</span>
    <span class="comment">%                 + real(v_fft(i,j,k))*real(v_fft(i,j,k))+imag(v_fft(i,j,k))*imag(v_fft(i,j,k)) ...</span>
    <span class="comment">%                 + real(w_fft(i,j,k))*real(w_fft(i,j,k))+imag(w_fft(i,j,k))*imag(w_fft(i,j,k)));</span>

    <span class="comment">%             end</span>
    <span class="comment">%             spec(kappa_pos) = spec(kappa_pos) + kappa*kappa*0.5*(phi_x(i,j,k).^+phi_y(i,j,k).^2+phi_z(i,j,k).^2);</span>
                  phi = 0.5*(phi_x+phi_y+phi_z);
                  phi = phi(1:round(size(phi_x,1)/2),<span class="keyword">...</span>
                            1:round(size(phi_y,1)/2),<span class="keyword">...</span>
                            1:round(size(phi_z,1)/2));
<span class="comment">%             end</span>
<span class="comment">%         end</span>
<span class="comment">%     end</span>
<span class="keyword">else</span>
<span class="comment">%     phi = u_fft;</span>
<span class="comment">%     phi(:,:)=0.0;</span>
<span class="comment">%     for j=1:dim</span>
<span class="comment">%         for i=1:dim</span>
<span class="comment">%             phi(i,j) = phi(i,j) +(phi_x(i,j)+phi_y(i,j));</span>
<span class="comment">%         end</span>
<span class="comment">%     end</span>
    phi = 0.5*phi_x+phi_y;
    phi = phi(1:round(size(phi_x,1)/2),<span class="keyword">...</span>
              1:round(size(phi_y,1)/2));
<span class="comment">%     phi = phi(1:round(size(phi,1)));</span>
<span class="keyword">end</span>
</pre><h2>compute k vector<a name="12"></a></h2><pre class="codeinput"><span class="keyword">if</span> (strcmp(<span class="string">'3D'</span>,flag))
    maxdim = sqrt(dim^2*(2*pi/Lx)^2+dim^2*(2*pi/Ly)^2+dim^2*(2*pi/Lz)^2);
    E=zeros(uint64(sqrt(3*dim^2)),1);
    kk=zeros(uint64(sqrt(3*dim^2)),1);
    dim = size(phi,1);
    <span class="keyword">for</span> k=1:dim
        <span class="keyword">for</span> j=1:dim
            <span class="keyword">for</span> i=1:dim
                kappa=sqrt(i*i*(2*pi/Lx)^2+j*j*(2*pi/Ly)^2+k*k*(2*pi/Lz)^2);
                kappa_pos=uint64(sqrt(i*i+j*j+k*k));
                E(kappa_pos) = E(kappa_pos) + phi(i,j,k);
                kk(kappa_pos) = kappa;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    E=E*4*pi;
<span class="comment">% E=E.*kk.^2;</span>
<span class="keyword">else</span>
    dim = size(phi,1);
    maxdim = sqrt(dim^2*(2*pi/Lx)^2+dim^2*(2*pi/Ly)^2);
    E=zeros(uint64(sqrt(dim^2+dim^2)),1);
    kk=zeros(uint64(sqrt(dim^2+dim^2)),1);
    bin_counter=zeros(uint64(sqrt(dim^2+dim^2)),1);
    <span class="keyword">for</span> j=1:dim
        <span class="keyword">for</span> i=1:dim
            kappa=sqrt(i*i*(2*pi/Lx)^2+j*j*(2*pi/Ly)^2);
            kappa_pos=uint64(sqrt(i*i+j*j));
            E(kappa_pos) = E(kappa_pos) + phi(i,j);
			bin_counter(kappa_pos) = bin_counter(kappa_pos) + 1;
            kk(kappa_pos) = kappa;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    EE=E*2*pi.*kk./bin_counter;
<span class="comment">%     EEE = E*2*pi.*kk;</span>
<span class="keyword">end</span>
</pre><h2>compute 1D spectrum<a name="13"></a></h2><p>close all</p><pre class="codeinput">slope=1.5*664092^(2/3)*(kk.^(-5/3));
<span class="comment">% test=importdata('INPUT/2D/CTRL_TURB_ENERGY');</span>
<span class="comment">%</span>
<span class="comment">% dissip=664092;</span>
dissip=664092;
up=17;
L=Lx;
kkke=kk./(2*pi)*L;
kkkd=kk./(2*pi*100)*L;
VKP = 1.5*17^5/dissip.*(kkke).^4./(1+kkke.^2).^(17/6).*exp(-3/2*1.5.*(kkkd).^(4/3));
<span class="comment">%</span>
loglog(kk,slope,kk,VKP,kk(2:end),E(2:end))
ylim([1e-14 10]);
h=legend(<span class="string">'Kolmogorov'</span>,<span class="string">'VKP'</span>,<span class="string">'Computed'</span>);
set(h,<span class="string">'Location'</span>,<span class="string">'SouthWest'</span>)
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
%% DOCUMENT TITLE
% INTRODUCTORY TEXT

%% Clear complete workspace
% Its always a good idea to clear the complete workspace and the command
% window also closing all figures might be helpful. You may also use the
% header defin some neccessary flags distinguishing bewteen different data
% sets.
close all
clear all
clc

flag='2D';
datadir='data';

%% Read data files
% Read in the data files and measure the time for reading. The output of
% the tic/toc block is in seconds. What you should get from the tic/toc
% block is that most of the time is spend during data I/O. The actual
% computation needs only ??? of the time of the I/O operations.

%%% 3D
if (strcmp('3D',flag))
    tic; % enable timer
    uvel=importdata([datadir,'/',flag,'/uvel']);
    vvel=importdata([datadir,'/',flag,'/vvel']);
    wvel=importdata([datadir,'/',flag,'/wvel']);
    time_reading = toc; % end timer
end
%%% 2D
if (strcmp('2D',flag))
    tic;
    uvel=importdata([datadir,'/',flag,'/uvel']);
    vvel=importdata([datadir,'/',flag,'/vvel']);
    time_reading = toc;
end
%% Set some neccessary parameters
% For further computations it is important to define some parmeters of the
% DNS simulation such as domain size, grid spacing, and the number of grid
% points.
%%% 3D
if (strcmp('3D',flag))
    dim=256; % number of points in one dimension
    Lx=5e-3; % domain size
    Ly=Lx;
    Lz=Lx;
    dx=Lx/dim; % grid spacing
    dy=dx;
    dz=dx;
    nu=1.7e-5; % viscosity
    u=reshape(uvel,dim,dim,dim); % reshape arrays to have them in 3D
    v=reshape(vvel,dim,dim,dim);
    w=reshape(wvel,dim,dim,dim);
end
%%% 2D
if (strcmp('2D',flag))
    dim=1024; % number of points in one dimension
    Lx=1E-2;  % domain size
    Ly=Lx;
    dx=Lx/dim; % grid spacing
    dy=dx;
    u=reshape(uvel,dim,dim); % reshape arrays to have them in 2D
    v=reshape(vvel,dim,dim);
end
%% Compute FFT
% This is the most important part of the script. Since the performance of
% an actual DFT is rather bad the preferred choice is a FFT. The FFT
% approach is fastest if the data set to be transformed has a size that is
% a multiple of two. Thats why the function *nextpow2* is used to get the
% next powert of two approximating the dimension _dim_ of the data set. As
% a consequence the data set is zero padded or truncated. Since the output
% of an FFT operation is symmetric we only need to save half the transform.
% <latex>
% \begin{tabular}{|c|c|} \hline
% $n$ & $n!$ \\ \hline
% 1 & 1 \\
% 2 & 2 \\
% 3 & 6 \\ \hline
% \end{tabular}
% </latex>
% 
% <latex>
%   \begin{equation}
%      \Phi_{ij}(\kappa)=\frac{1}{(2\,\pi)^3}\iiint^{\infty}_{-\infty}
%                           R_{ij}(\mathbf{r})\,\mathrm{e}^{-i\mathrm{\kappa}r}
%                           \,\mathrm{d}\mathbf{r}
%   \end{equation}
% </latex>
if (strcmp('3D',flag))
    tic;
    NFFT = 2.^nextpow2(size(u)); % Next power of 2 from length of u
    u_fft=fftn(u,NFFT);
    %
    NFFT = 2.^nextpow2(size(v));
    v_fft=fftn(v,NFFT);
    %
    NFFT = 2.^nextpow2(size(w));
    w_fft=fftn(w,NFFT);
    time_fft=toc;
    
    phi_x=u_fft.*conj(u_fft)/dim^6;
    phi_y=v_fft.*conj(v_fft)/dim^6;
    phi_z=w_fft.*conj(w_fft)/dim^6;
end
if (strcmp('2D',flag))
    NFFT = 2.^nextpow2(size(u));
    u_fft=fft2(u,NFFT(1),NFFT(2))./(2*pi)^2; %2pi comes from the definition of FFT
%     u_fft = u_fft(1:NFFT(1)/2+1,1:NFFT(2)/2+1);
    NFFT = 2.^nextpow2(size(v));
    v_fft=fft2(v,NFFT(1),NFFT(2))./(2*pi)^2;
%     v_fft = v_fft(1:NFFT(1)/2+1,1:NFFT(2)/2+1);
       
    phi_x=u_fft.*conj(u_fft)/size(u,1).^2/size(u,2).^2;
    phi_y=v_fft.*conj(v_fft)/size(v,1).^2/size(v,2).^2;
end

%% Compute correlations
% Computing a correlation can be a tedious work (requireing tremendous effort)
% especially if you have large data sets. From theory it is well known that
% the multiplication of the transform of a data set and ist complex
% conjugate give a accurate representation of the correlation function.
% Using the FFT approach this gives an enormeous speed advantage.

if (strcmp('3D',flag))
    R11=ifftn(u_fft.*conj(u_fft))/dim^3/std2(u)^2;
    R22=ifftn(u_fft.*conj(u_fft))/dim^3/std2(v)^2;
    R33=ifftn(u_fft.*conj(u_fft))/dim^3/std2(w)^2;
    R11=R11(1:round(size(R11,1)/2),1,1);
    R22=R22(1:round(size(R22,1)/2),1,1);
    R33=R33(1:round(size(R33,1)/2),1,1);
    r = linspace(0,Lx/2,dim/2)/(Lx/2);
else
    NFFT = 2.^nextpow2(size(u_fft));
    R1 = ifft2(u_fft.*conj(u_fft),NFFT(1),NFFT(2))...
                ./NFFT(1)./NFFT(2)./std2(u)^2 ...
                .*(2*pi)^4; % scaling due to division by 2*pi
    %
    NFFT = 2.^nextpow2(size(v_fft));
    R2 = ifft2(v_fft.*conj(v_fft),NFFT(1),NFFT(2))...
                ./NFFT(1)./NFFT(2)./std2(v)^2 ...
                .*(2*pi)^4; % scaling due to division by 2*pi                
%     R11= ifftn(fftn(u).*conj(fftn(u))/dim^2/std2(u)^2);
%     R22=ifftn(fftn(v).*conj(fftn(v))/dim^2/std2(v)^2);
    R11 = (R1(1:round(size(R1,1)/2),1) + ...
           R2(1,1:round(size(R2,1)/2))')/2;
    R22 = (R2(1:round(size(R2,1)/2),1) + ...
           R1(1,1:round(size(R1,1)/2))')/2;
    
%     R11 = (R11 + R2(1,1:round(size(R2,1)/2))')/2;
    
%     r = linspace(0,Lx/2,dim/2)/(Lx/2);
%     test = R11 + r'/2.*gradient(R11,max(diff(r)));
%     plot(r,R11,r,R22,r,test)
%     legend('R11','R22','Equation');
%     h=line([0 1],[0 0],'Color',[0 0 0],'LineWidth',1.0);
end
%% Show graphs
pcolor(fftshift(R1));shading interp;title('R11');
figure
pcolor(fftshift(R2));shading interp;title('R22');

%% compute length scales
L11=trapz(r,R11);
L22=trapz(r,R22);
hold on
rectangle('Position',[0,0,L11,1],'LineWidth',2,'LineStyle','REPLACE_WITH_DASH_DASH')

%% compute 1D spectrum
L=length(R1);
NFFT=2^nextpow2(L);
spec_1D=fft(R1(:,1),NFFT)/L.*2/pi;

f = linspace(0,1,NFFT)*2*pi/dx;

slope=1.5*664092^(2/3)*(f.^(-5/3));
% loglog(f,2*abs(spec_(1:NFFT/2+1)));
% hold on
% loglog(f,slope);
%% compute spectrum
% spec = zeros(round(dim*dim*dim/8),1);
if (strcmp('3D',flag))
%     phi = u_fft;
%     phi(:,:,:)=0.0;
%     for k=1:dim
%         for j=1:dim
%             for i=1:dim
    %             kappa = sqrt(i*i+j*j+k*k);
    %             kappa_pos=int16(kappa);
    %             if (kappa_pos <= size(spec,1))
    %                 spec(kappa_pos) = spec(kappa_pos)+kappa*kappa*(...
    %                 + real(u_fft(i,j,k))*real(u_fft(i,j,k))+imag(u_fft(i,j,k))*imag(u_fft(i,j,k)) ...
    %                 + real(v_fft(i,j,k))*real(v_fft(i,j,k))+imag(v_fft(i,j,k))*imag(v_fft(i,j,k)) ...
    %                 + real(w_fft(i,j,k))*real(w_fft(i,j,k))+imag(w_fft(i,j,k))*imag(w_fft(i,j,k)));

    %             end
    %             spec(kappa_pos) = spec(kappa_pos) + kappa*kappa*0.5*(phi_x(i,j,k).^+phi_y(i,j,k).^2+phi_z(i,j,k).^2);
                  phi = 0.5*(phi_x+phi_y+phi_z);
                  phi = phi(1:round(size(phi_x,1)/2),...
                            1:round(size(phi_y,1)/2),...
                            1:round(size(phi_z,1)/2));
%             end
%         end
%     end
else
%     phi = u_fft;
%     phi(:,:)=0.0;
%     for j=1:dim
%         for i=1:dim
%             phi(i,j) = phi(i,j) +(phi_x(i,j)+phi_y(i,j));
%         end
%     end
    phi = 0.5*phi_x+phi_y;
    phi = phi(1:round(size(phi_x,1)/2),...
              1:round(size(phi_y,1)/2));
%     phi = phi(1:round(size(phi,1)));
end
%% compute k vector
if (strcmp('3D',flag))
    maxdim = sqrt(dim^2*(2*pi/Lx)^2+dim^2*(2*pi/Ly)^2+dim^2*(2*pi/Lz)^2);
    E=zeros(uint64(sqrt(3*dim^2)),1);
    kk=zeros(uint64(sqrt(3*dim^2)),1);
    dim = size(phi,1);
    for k=1:dim
        for j=1:dim
            for i=1:dim
                kappa=sqrt(i*i*(2*pi/Lx)^2+j*j*(2*pi/Ly)^2+k*k*(2*pi/Lz)^2);
                kappa_pos=uint64(sqrt(i*i+j*j+k*k));    
                E(kappa_pos) = E(kappa_pos) + phi(i,j,k);
                kk(kappa_pos) = kappa;
            end
        end
    end
    E=E*4*pi;
% E=E.*kk.^2;
else
    dim = size(phi,1);
    maxdim = sqrt(dim^2*(2*pi/Lx)^2+dim^2*(2*pi/Ly)^2);
    E=zeros(uint64(sqrt(dim^2+dim^2)),1);
    kk=zeros(uint64(sqrt(dim^2+dim^2)),1);
    bin_counter=zeros(uint64(sqrt(dim^2+dim^2)),1);
    for j=1:dim
        for i=1:dim
            kappa=sqrt(i*i*(2*pi/Lx)^2+j*j*(2*pi/Ly)^2);
            kappa_pos=uint64(sqrt(i*i+j*j));
            E(kappa_pos) = E(kappa_pos) + phi(i,j);
			bin_counter(kappa_pos) = bin_counter(kappa_pos) + 1;
            kk(kappa_pos) = kappa;
        end
    end
    EE=E*2*pi.*kk./bin_counter;
%     EEE = E*2*pi.*kk;
end

%% compute 1D spectrum
% close all

slope=1.5*664092^(2/3)*(kk.^(-5/3));
% test=importdata('INPUT/2D/CTRL_TURB_ENERGY');
%
% dissip=664092;
dissip=664092;
up=17;
L=Lx;
kkke=kk./(2*pi)*L;
kkkd=kk./(2*pi*100)*L;
VKP = 1.5*17^5/dissip.*(kkke).^4./(1+kkke.^2).^(17/6).*exp(-3/2*1.5.*(kkkd).^(4/3));
%
loglog(kk,slope,kk,VKP,kk(2:end),E(2:end))
ylim([1e-14 10]);
h=legend('Kolmogorov','VKP','Computed');
set(h,'Location','SouthWest')

##### SOURCE END #####
--></body></html>